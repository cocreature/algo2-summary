* Bewegungsplanung bei unvollständiger Information
** Ausweg aus einem Labyrinth
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf::1][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf]]
- Labrinth L mit Roboter R mit Tastsensor, Meßgerät für Drehwinkel φ
  und Fähigkeit Inneres und Äußeres von L zu unterscheiden
*** Pledge-Strategie
- Solange R∈L
- Gehe vorwärts bis R∉L oder Wandkontakt
- Gehe links der Wand bis ∉L oder φ=0
*** Hat der Weg von R unendlich viele Kanten K_{1},K_{2},… ist R eingeschlossen
** Zum Ziel in unbekannter Umgebung
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf::5][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf]]
- P_{1},…,P_{n} disjunkte einf. zsh. endl. polygonale Gebiete des ℝ^{2}
- s,z Start und Ziel ∈ ℝ^{2}\∪_{i=1}^{n} P_{i} =: F
- R Roboter der zusätzlich wie zuvor, der zusätzlich die eigene Position kennt
*** Wanze
- Solangee r ≠ z
  - laufe in Richtung z bis r=z oder ∃i: r∈P_{i}
  - Falls r≠z
    - umlaufe P_{i} und suche ein q∈argmin‖x-z‖_{2}, x∈P_{i}
    - Gehe zu q
- Kann Wege erzeugen, die beliebig länger als der kürzeste sind
*** Steuerworte
- z: gehe in Richtung z soweit möglich
- l: gehe links einer Kante bis zu deren Endpunkt
- r: gehe rechts einer Kante bis zu deren Endpunkt
*** Universelles Steuerwort
- Es gibt ein universelles Steuerwort w, dass für alle Startpunkte zum gegebenen Ziel z führt, d.h
  - w(F):={w(x)|x∈F}={z}
  - Befehle werten ignoriert, wenn sie nicht anwendbar sind,
    insbesondere bewegt man sich vom Ziel nicht weg
- Es reicht also aus einfach alle endlichen Steuerworte zu erzeugen
**** Beweis
- Zu den Ecken p_{1},…,p_{m} aller P_{i} wähle sukzessiv Steuerworte w_{1},…,w_{m} sodass
  - w_{i},…,w_{1}(p_{i})=z
- w_{m}…w_{1}lz(s)=z ist universelles Steuerwort
** Das Behälterproblem
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf::8][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf]]
- verteile B=(b_1,…,b_m)⊂(0,h] auf möglichst wenige Teilfolgen B_{1}…B_{k} sodass
  - ∀i=1,…,k: Σ_{B_{i}} ≤ h
- NP-Hart
*** First Fit
- In ersten Behälter der genug Platz hat reinpacken
*** Kompetitivität
- P Problem, A korrekter Algorithmus für P, k_{min}(e) und k_{A}(e) Größe der Lösungen bei Eingabe e
- A ist kompetitiv c-kompetitiv ≔ k_{A} ≤ a+c*k_{min}
** Türsuche
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf::10][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf]]
*** Algorithmus
- Wähle Erkundungstiefen f_{i}>0 für i∈ℕ
- i≔1
- Wiederhole bis Tür gefunden
  - gehe f_{i} Meter die Wand entlang
  - kehre Laufrichtung um
  - gehe f_{i} Meter die Wand entlang
  - i≔i+1
*** Beispiele
- f_{i}≔i
  - Nicht kompetitiv, da quadratisch
- f_{i}≔2^i
  - d≔f_{n}+ε∈(f_{n},f_{n+1}]
  - L ≔
    - 2Σ^{n} + d oder
    - 2Σ^{n+1} + d
    - < 2*2^{n+2}+d < 8(2^{n}+ε)+d = 9d
    - 9-kompetitiv
*** 9 ist optimal
- Beweis über Matrixiteration
** Sternsuche
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf::15][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf]]
- Halbgeraden H_{1},…,H_{m} die von Startpunkt s ausgehen und Zielpunkt z auf den Geraden
- H_{i+m}≔H_{i}
*** Algorithmus
- Wähle Erkundungstiefen f̲{i}>0 für i∈ℕ
- i≔1
- Wiederhole bis z gefunden
  - gehe f_{i} Meter auf H_{i} entlang und zurück
  - i≔i+1
*** Beispiele
- f_{i}=(m/(m-1))^{i}
  - c-kompetitiv mit
  - c≔ $2 m (\frac{m}{m-1})^{m-1}+1$ < 2me+1
  - optimial
** Polygonsuche
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf::17][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-1.pdf]]
- P einfach zsh. beschr. polygonales Gebiet mit n Ecken und durch Mauer berandet
- R Roboter der Koordinaten sichtbarer Punkte mit Sichtsystem bestimmen kann
- s,z Punkte in P
** Beispiele
- n/4 Korridore der Länge 1+ε mit abgewinkelten Spitzen der Länge ε
  - um z zu finden muss R im schlechtesten Fall alle Korridore ablaufen
  - Länge des Kompetivitätsfaktor hängt von n ab
** Lemma
- Es gibt kürzesten Weg von s nach z in P
- Er ist polygonal und Ecken sind s,z oder Acken von P
*** Beweis
- S(p) Bereich von P der von p aus gesehen werden kann
- Falls z∈S(s)
  - sz der kürzeste Weg
- Falls z∉S(s)
  - jeder Weg W von s nach z kreuzt eine Kante pq von S(s)
  - Kante pq zerlegt P in zwei Polygone s∈P_{s} und z∈P_{z}
  - Wird W bis zum letzten Kreuzungspunkt r durch sr ersetzt, liegt W
    ab p ganz in P_{z} und entspricht bis p dem kürzesten Weg von s
    nach z
  - Analog fortsetzen
** Baum der kürzesten Wege (BkW) von s zu den Ecken von P
- m Blätter, dann gilt m≤n
- Kennt R BkW kann er die m Wege mit Sternsuche ablaufen, bis er z sieht
- Kompetitvitätsfaktor ∈ O(n)
* Konvexe Hüllen
** Dualität
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf::2][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf]]
- Die Punkte x ≔ [1,x'], x'∈ℝ^{d} bilden einen affinen Raum A^{d}
- Abgeschlossene Halbräume von A^{d} sind definiert durch
  - u^{t}x := [u_{0},…,u_{d}][1,x_{1},…,x_{d}]≥0
  - u bezeichnet Halbraum und x einen seiner Punkte
  - Halbräume enthalten Ursprung
    - u_0>0
    - normiere u sodass u_{0}=1
  - Halbraum ist eineindeutig durch Koordinatenvektor u≔[1,u'], u'∈ℝ^{d} beschrieben
  - u^{*} ist der zu u gehörige Halbraum
- Menge der Halbräume bildet den Dualraum A^{*} von A
  - Halbraum [1,…,0]^{t} ist Ausnahme, da er den gesamten Raum A enthält
- x∈u^{*} ↔ u∈x^{*}
** Konvexe Mengen
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf::3][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf]]
- Verbindungsstrecke von a und b entspricht den Punkten
  - x≔a*(1-t)+bt, t∈[0,1]
- Teilmenge von A heißt konvex wenn sie zu je zwei Punkten auch
  Verbindungsstrecke enthält
- a^{*}b^{*} besteht aus Halbräumen mit den Koordinaten x≔a*(1-t}+bt, t∈[0,1]
- Konvexe Hülle einer Menge M
  - Schnitt aller konvexen Obermengen
  - bezeichnet mit [M]
*** Beispiele
- Für eine beliebige Punktmenge M⊂A bilden die Halbräume, die M
  enthalten, eine konvexe Menge im Dualraum
- Ist M^{*}⊂A^{*} eine Halbraummenge, bilden alle PUnkte, die in allen
  m^{*}∈M^{*} enthälten sind eine konvexe Menge im Primalraum A
** Konvexe Polyeder
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf::6][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf]]
- Konvexes Polyeder P⊂A ist Schnitt endlich vieler Halbräume u_{1}^{*},…,u_{n}^{*}∈A^{*}
- Rand einer beliebigen Menge M wird mit ∂M bezeichnet
- die planaren Teile von ∂P bilden die Facetten von P
- jede Facette von P liegt auf Rand eines halbraums u_{i}^{*} (Facettenhalbraum (FHR))
- Benachbarte Facetten schneiden sich in den Kanten von P
- Endpunkte liegen auf mindestens 3 Facetten und bilden Ecken/Extrempunkte von P
*** Konvexes Polyeder P ist konvexe hülle K seiner Eckenmenge
*** Halbräume die konvexes Polyeder P enthälten, bilden konvexe Hülle K^{*} der FHRe von P
*** Folgerung
- Ist P konvexes Polyeder mit Ecken p_{1},…,p_{e} und den FHRen
  u_{1}^{*},…,u_{f}^{*} hat die Menge
  - U^{*}:={u^{*}|u^{*}⊃P}⊂A^{*} die Ecken u_{1}^{*},…,u_{f}^{*} und die FHRe p_{1},…,p_{e}
- Dual: U≔{u|u^{*}⊃P}⊂A hat die Ecken u_{i} und die FHRe p_{i}^{*} hat
- Polyeder P und U⊂A heißen dual zueinander
** Beziehungen zwischen Knoten, Kanten, Facetten
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf::10][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf]]
- plangraph stuff
** Datenstruktur für Netze
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf::12][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf]]
Für jede Ecke p
- Koordinaten von p
- Listen von Zeigerpaaren
  - 1. Zeiger weißt im Gegenuhrzeigersinn (GUS) geordnet auf alle Nachbarn von p
  - sind p,q,r im GUS geordnete Nachbarn einer Facette und weist
    der 1. Zeiger eines Paares auf q, zeigt der 2. Zeiger indirekt auf
    r, Er weist auf das Zeigerpaar von q, dessen 1. Zeiger auf r weist
** Algorithmus konvexe Hülle
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf::14][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf]]
- Grob
  - Verschiebe
  - U_{i}←p_{1}^{*}∩…∩p_{4}^{*}
    - Für i=5,…,n
      - Falls U_{4}⊂p_{i}^{*}
        - Markiere p_{i} als gelöscht
      - Sonst
        - Verknüpfe p_{i} bidirektional mit einem Knoten von U∉p_{i}^{*}pp (hier u_{i} genannt)
  - Für i=5,…,n
    - U_{i}←U_{i-1}∩p_{i}^{*}
      - für i=5,…,n, wenn p_{i} unmarkiert
        - Suche Eckenmenge Q_{i}≔{q_{1},…,q_{k}} von U_{i-1}∩∂p_{i}^{*}
        - U_{i} ← U_{i-1} + Facette Q_{i}
        - Löschen von U_{i}, was ∉ p_{i}^{*}
          - Dabei Datenstruktur updaten
  - Dualisiere und verschiebe wieder
** Aufwand des Algorithmus „Konvexe Hülle“
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf::17][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-2.pdf]]
- Reihenfolge der p_{i} gleichverteilt zufällig
- Jede Ecke hat Knotengrad 3 (Mehrfachpunkte und degenerierte Kanten, falls das nicht der Fall ist)
- O(nlogn) erwartet
- Asymptotisch O(n^2)
* Distanzprobleme
- Solve all your problems by magic
  - NN
  - maximaler leerer Kreis
  - minimaler Spannbaum
  - kürzeste Rundreise
  - Bewegungsplanung
  - Triangulierung mit maximalem kleinsten Winkel
  - Uniforme Verteilung von Punkten oder isotrope Parkettierung
  - Bestimmung der medialen Achse (Skelett) eines Gebiets/Objekts
** Voronoi-Diagramma
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-3.pdf::2][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-3.pdf]]
- P≔{p_{1},…,p_{n}}⊂ℝ^{2}
- Voronoigebiet eines der p_{i} bezüglich P ist
  - V_{i}≔{x∈ℝ^{2}|∀j=1,…,n: ‖x-p_{i}‖_{2}≤‖x-p_{j}‖_{2}}
  - V_{i} konvex, da Schnitt der Halbebenen,
    H_{ij}≔{x∈ℝ^{2}|‖x-p_{i}‖_{2}≤‖x-p_{j}‖_{2}}
- Kanten der V_{i} bilden Voronidiagramm V(P)
- Schneiden sich 3-Voronigebiete V_{i_{0}},V_{i_{1}} und V_{i_{2}} in
  einem Punkt q, liegen p_{i_{0}}, p_{i_{1}} und p_{i_{2}} auf einem
  Kreis mit Mittelpunkt q
  - Solch ein Kreis heißt V-Kreis und der Mittelpunkt V-Knoten
  - Voronoikreis ist leer, offene Kreisscheibe enthält kein p_{j}
** Delaunay-Triangulierungen
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-3.pdf::4][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-3.pdf]]
- Delaunay-Triangulierung :(P) von P={p_{1},…,p_{h}}⊂ℝ^{2} hat Kantenmenge
  - {p_{i}p_{j} | V_{i}∩V_{j} ist Kante des Voroni-Diagramms V(P)}
  - Dualgraph zu V(P)
- Annahme: Jeder Voronikreis gehe nur durch 3 Punkte
- Die zu den V-Knoten dualen Gebiete von D(P) sind disjunkte Dreiecke
  die die kovexe Hülle [P] zerlegen
** Eigenschaften von Delaunaytriangulierungen
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-3.pdf::6][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-3.pdf]]
- Leere Umkreiseigenschaft
  - Eine Triangulierung von P ist genau dann Teil von D(P), wenn Umkreise der Dreiecke leer sind
- Paraboloideigenschaft
  - Rotationsparaboloid R definiert durch z(x,y)=x^2+y^2
  - Q≔{[p_{i},z(p_{i})]|i=1,…,n}
  - Projeziert man den unteren Teil der konvexen Hülle [Q] orthogonal auf die xy-Ebene, erhält man D(P)
  - D(P) kann mit Algorithmus konvexe Hülle und mittlerem Aufwand ∈O(nlogn) berechnet werden
  - Kanten einer Triangulierung von Q sind konvex (Tal) oder konkav
    (Berg), ersetz successiv in konkave durch konvexe Kanten
- Winkeleigenschaft
  - Der kleinste Winkel einer Triangulierung eines Vierecks ist für
    die DT größer als für die andere Triangulierung
** Nächste Nachbarn
- In einer Punktmenge {p_1,…,p_n} ist jeder Punkt p_i mit seinem
  Nächsten Nachbarn durch eine Delaunay-Kante verbunden, da
  - 1/2(p_{i}+p_{j})∈V_{i}∩V_{j}, weswegen V_{i} und V_{j} benachbart
    sind
  - Kennt man die Delaunay-Triangulierung können die nächsten Nachbarn
    aller p_{i} mit einem Aufwand in O(n) bestimmt werden
** Minimaler Spannbaum
- Minimale Spannbäume von P liegen auf D(P)
** kürzeste Rundreise
- Rundweg um einen minimalen Spannbaum ist weniger als doppelt so lang
  wie der kürzeste
* Stationäre Unterteilung für Kurven
- stationär, weil immer derselbe Unterteilungsoperator verwendet wird
** Kardinale Splines
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-4.pdf::6][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-4.pdf]]
*** Kardinale B-Splines vom Grad n
- N^{0}(u)≔{1, u∈[0,1), 0, sonst
- N^{n}(u)≔ integral_{-∞}^{u} N^{n-1}(t) - N^{n-1}(t-1) dt
          = integral_{u-1}^{u} N^{n-1}(t) dt
**** Eigenschaften
- N^{n}(u){ =0, u∉[0,n+1), >0, u∈(0,n+1)
- N^{n} hat den Träger supp N^{n}=[0,n+1]
- Translate N^{n}_{i}(u)≔N^{n}(u-i), i∈ℤ bilden eine nicht negative
  Zerlegung der Eins
*** Kardinalspline
- s(u):=Σ_{i∈ℤ} c_{i}N_{i}^{n}(u) : ℝ→ℝ^{d} heißt Kardinalspline
- c_{i} sind Kontrollpunkte und bilden die Ecken des Kontrollpolygons
- Spline ist Konvexkombination seiner Kontrollpunkte:
  - Für u∈[i+n,i+n+1) liegt s(u)≔Σc_{i}N_{i}^{n}(u) in der konvexen
    Hülle von c_{i},…,c_{i+n}
- s' = Σ_{i∈ℤ} c_{i}(N_{i}^{n-1}-N_{i+1}^{n-1}) = Σ_{i∈ℤ} ∇c_{i}N_{i}^{n-1}
  - ∇c_{i} = c_{i}-c_{i-1}
** Lane-Riesenfeld Algorithmus
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-4.pdf::9][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-4.pdf]]
- Spline s≔Σc_{i}N_{i}^{n} kann als Linearkombination der skalierten
  Translate N_{i}^{n}(2u)=N^{n}(2u-i) dargestellt werden
  - s(u)=Σ_{i∈ℤ} c_{i}^{1}N^{n}(2u-i)
*** Algorithmus
- Für i∈ℤ verdopple
  - d_{i}^{0} ← c_{floor(i/2)}
- Für k=1,…,n
  - Für i∈ℤ mittele
    - d_{i}^{k}←½(d_{i-1}^{k-1} + d_{i}^{k-1})
- Für i∈ℤ
  - c_{i}^{1}←d_{i}^{k}
*** Iterieren
- s(u)=Σ c_{i}^{k} N_{i}^{n} (2^{k} u - i)
  - c_{i}^{k} werden aus den c_{i}^{k-1} sowie die c_{i}^{1} aus den
    c_{i} berechnet werden
** Konvergenz bei L.-R.-Unterteilung
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-4.pdf::12][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-4.pdf]]
- Unterteile s(u)≔Σ_{i∈ℤ} c_{i}^{0} N^{n}(u-i)
- erhalte s(u)=Σ_{i∈ℤ} c_{i}^{k} N^{n}(2^{k}u-i)
- Kontrollpolygone c_{k}≔(…,c_{-1}^{k},c_{0}^{k},c_{1}^{k},…)
- Die Kanten der Kontrollpol. werden durch einen Verdopplungsschritt
  mit Mittelungsschritt halbiert und bei weiteren Mittelungen nicht
  länger
- Somit gilt für die maximalen Kantenlängen
  - h_{k} ≔ sup_{i∈ℤ} ‖∇c_{i}^{k}‖_{2}
  dass
  - h_{k}≤1/2h_{k-1}≤…≤1/(2^{k}) h_{0}
- Durchmesser konvexer Hüllen n+1 adjazenter c_{i}^{k} lassen sich durch
  - n*h_{k} ∈ O(2^{-k})
- Somit konvergieren die Kontrollpolygone von s gegen den Spline s
** Unterteilungsmatrizen
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-4.pdf::14][/home/moritz/docs/studium/algo2/Algo-2-Kapitel-4.pdf]]
- Drücke LR-Algorithmus durch Matrizen und symbolische Polynomprodukte aus
- skalarwertiges Polygon c≔[…,c_{-1},c_{0},c_{1},…] ∈ ℝ^{ℤ}
- Verdoppeln d≔Dc≔ (Matrix doppelter Höhe mit jeweils 2 Einsen pro Spalte) c
- Mitteln Md≔½ 1/2 (quadratische Matrix mit je zwei Einsen pro Reihe, die sich überlappen ) d
- Matrizen sind biinfinit
- Im 1. LR-Schritt M^{n}Dc für Grad n und in m Schritten U^{m}_{n}c,
  wobei U_{n}≔M^{n}D
- Unterteilungsmatrizen U_{n} n∈ℕ_{0} stellen den LR-ALgorithmus dar
  und können durch n-fache Mitteilungen der Spalten von D berechnet
  werden
- [[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Kapitel-4.pdf::16][Unterteilungsgleichung]]
- b_{i}=Σ_{k∈ℤ}α_{i-2k} c_{k}, i∈ℤ
  - α sind die Einträge der Spalten von U_{n} die jeweils immer um 2 Verschoben sind
  - b entspricht U_{n}c
** Das Symbol
- Darstellung der Folgen b,a,c durch symbolische Polynome
  - b(z) ≔ Σ_{i∈ℤ} b_{i} z^{i}
  - analog für α und c
- Unterteilungsgleichung über Polynome b(z)=α(z)c(z^{2})
- Verallgemeinerung indem α(z) durch ein beliebiges Polynom ersetzt wird
- α(z) heißt Symbol des Unterteilungsalgorithmus
- Für LR α_{n}(z)≔1/(2^{n}) (1+z)^{n+1}
- Dopplungsmatrix: α_{0}(z) ≔ 1+z
- Mittelungsmatrix: μ(z) ≔ 1/2 (1+z)
** Differenzenschema
- c≔c_{ℤ}≔(c_{i})_{i∈ℤ} Kontrollpolygon
- ∇c_{i} bilden das Differenzenpolygon
  - ∇c ≔ (∇c_{i})_{i∈ℤ}
  - Differenzenoperator ist auch als Matrix mit -11 pro Reihe darstellbar
  - Symbol ∇(z) ≔ 1-z
- c_{∇}(z)≔Σ_{i∈ℤ}(c_{i}-c_{i-1}) z^{i} = (1-z) c(z) = v(z) c(z)
- Für
  - α(z) Symbol eines bel. stat. UAalg
  - b(z)≕α(z)c(z^{2})
  - Folgt
    - b_{∇}(z)=α(z)/(1+z) * c_{∇}(z^{2})
    - Differenzen können aus Differenzen des Ursprünglichen Polygons
      berechnet werden mit β(z)≔α(z)/(1+z)
    - β(z) heißt Differenzenschema zu α(z)
      - Existiert nur, wenn α(z) den Faktor (1+z) hat
** Konvergenz
- c^{m}(z)≔ α(z) * c^{m-1}(z^{2})
- Folge der Polygone c^{m} heißt konvergent, wenn die stückweise linearen Splines
  - Σ_{k∈ℤ} c_{k}^{m} N_{k}^{1}(2^{m} u) gleichmäßig gegen eine stetige Konvergenz f(u) konvergieren
- Unterteilungsalgorithmus α(z) heißt konvergent, falls für alle c^{0}(z) die Polygonfolge (c^{m})_{m∈ℕ} konvergent ist
- α heißt Nullschema, falls alle diese Folgen c^{ℕ} gegen f(u)≡0 konvergieren
- α heißt c^{r}-Schema, wenn alle Folgen c^{ℕ} gegen eine Funktion ∈ C^r konvergieren
- Im folgenden sind fast alle Koeffizienten von α = 0
*** Lemma
- Ist α(z) Symbol eines konvergenten Schemas gilt
- Σ_{j∈ℤ} α_{2j}=1
*** Satz
- Unterteilungsalgorithmus α ist konvergent gdw sein Differenzenschema Nullschema ist
*** Satz
- Unterteilungsalgorithmus α mit Differenzenschema β ist C^{1}-Schema, falls das Ableitungschema 2β konvergent ist
- Ist α ein C^{1}-Schema und konvergieren die Polygone c^{m}(z)=α(z)c^{m-1}(z^{2}) gegen f(u)
  konvergieren die skal. Diff.polygone 2^{m}(∇c_{i}^{m})_{i∈ℤ} gegen f'(u)
* Unterteilungsalgorithmen für Flächen
** Tensorprodukt-Unterteilungsalgorithmen
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Skript-86-87.pdf::1][/home/moritz/docs/studium/algo2/Algo-2-Skript-86-87.pdf]]
- C≔ [c_{ij}]_{i,j∈ℤ} beschreibt regelmäßiges biinfinites Vierecksnetz
- U und V Matrizen zweier stationärer Unterteilungsalgorithmen für Kurven
- Kontrollnetz B≔b_{ℤ^{2}}≔UCV^{t} indem alle Spalten von C mit U und dann alle Zeilen von UC mit V unterteilt werden
- (U,V) heißt Tensorproduktunterteilungschema (TEPUS)
- U^{m}C(V^{t})^{m} konvergieren gegen eine C^{r}-Fläche wenn U und V C^{r} konvergent sind
** Symbole
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Seiten87-94.pdf::1][/home/moritz/docs/studium/algo2/Algo-2-Seiten87-94.pdf]]
- Matrix C=c_{ℤ^{2}} hat Symbol
  - c(x)≔c(x,y)≔Σ_{i∈ℤ} Σ_{j∈ℤ} c_{ij} x^{i} y^{j} ≔ Σ_{i∈ℤ^{2}} c_{i} x^{i}
- Sind U,V stationaler U-Alg mit Symbolen α(x), β(y) hat B≔b_{ℤ^{2}}≔UCV^{t} das Symbol
  - b(x,y)≔α(x)c(x^{2},y^{2})β(y)
- γ(x,y)≔α(x)β(y) ist Symbol des Tepus und Unterteilungsgleichung ist
  - b(x)=γ(x)c(x^{2})
  - Ausmultiplizieren: b_{i}=Σ_{k∈ℤ^{2}} γ_{i-2k} c_{k}
- Auch wenn γ(x,y) kein Produkt von Symbolen ist, stellt γ einen stationären U-Alg dar
** Masken
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Seiten87-94.pdf::4][/home/moritz/docs/studium/algo2/Algo-2-Seiten87-94.pdf]]
- Γ≔[γ_{j}]_{j∈ℤ^{2}} Koeffizientenmatrix einer Unterteilungsgleichung
  - b_{i}=Σ_{k∈ℤ^{2}} γ_{i-2k} c_{k}
  - Nur 1/4 aller γ_{j} treten auf, diese bilden Teilmatrix
    - Γ_{i} ≔ [γ_{i-2k}]_{k∈ℤ^{2}}
    - Entspricht bis auf Indexverschiebungen einer der 4 Teilmatrizen Γ_{00},Γ_{10},Γ_{01},Γ_{11}
- Die 4 Teilmatrizen bilden eine Zerlegung von Γ und heißen Masken des U-Alg γ
- Spiegelung: [γ'_{k}]_{k∈ℤ^{2}] ≔ Γ_{i}
  - γ'_{k}=γ_{i-2k}
- b_{i}=Σ_{k∈ℤ^{2}} γ'_{k} c_{k} ist gewichtete Produktsumme, die
  graphisch dargestellt wird indem Gewichte γ'_{k} an Punkte c_{k}
  geschrieben werden
- Graphik [[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Seiten87-94.pdf::5][/home/moritz/docs/studium/algo2/Algo-2-Seiten87-94.pdf]]
- b_{i}≔Σ_{k∈ℤ^{2}} γ_{i-rk}c_{k} definiert r-näres Unterteilungschema mit r^{2} Masken
** Konvergenz
[[pdfview:/home/moritz/docs/studium/algo2/Algo-2-Seiten87-94.pdf::6][/home/moritz/docs/studium/algo2/Algo-2-Seiten87-94.pdf]]
- C≔(C^{m})_{m∈ℕ_{0}} Folge von regelmäßigen Vierecksnetzen mit Symbolen
  - c^{m}(x)≔Σ_{k∈ℤ^{2}} c_{k}^{m} x^{k} mit UGL
  - c^{m}(x)=γ(x)c^{m-1}(x^{2}), wobei
  - γ(x)≔Σ_{j∈ℤ^{2}} γ_{j}x^{j} und fast alle γ_{j}=0
- C heißt konergvent, falls die stückweise bilinearen Splines
  - s_{m}(x,y)≔Σ_{i,j∈ℤ} c_{ij}^{m} N_{i}^{1}(2^{m}x)
    N_{j}^{1}(2^{m}y) über jedem kompakten Gebiet gegen eine stetige
    Limesfläche s_{∞} konvergieren
  - Ist s_{∞}∈C^{r} heißt C C^{r}-konvergent
  - Für s_{∞}=0  heißt C 0-konvergent
- Binäres Schema γ heißt C^{r}-konvergent, wenn Netzfolge C für jedes Ausgangsnetz C^{0} C^{r}-konvergent ist
  - Konvergent, wenn C^{0}-konvergent
  - Nullschema, wenn C für jedes C^{0} Nullfolge ist
- Ist γ konvergent und kein Nullschema, gilt für alle i∈ℤ^{2}
  - Σ_{k∈ℤ^{2}} γ_{i-2k}=1
- ∇_{1} c_{ij} ≔ c_{ij} - c_{i-1,j}
- ∇_{2} c_{ij} ≔ c_{ij} - c_{i,j-1}
- ∇_{k}^{r} c_{ij} ≔ ∇_{k} ∇_{k}^{r-1} c_{ij}, k=1,2
*** Satz
Wenn für r,s∈ℕ_{0} mit r+s=k+1 das Netz der Differenzen
  ∇_{1}^{r} ∇_{2}^{s} c_{i}^{m}, i∈ℤ^{2}
für m→∞ eine Nullfolge bildet, ist γ ein C^{k}-Schema
** Verallgemeinerungen
*** Dreiecksnetze
- Unterteilungsalgorithmen für regelmäßige Dreiecksnetze können als
  Unterteilungsalgorithmen für regelmäßige Vierecknetze aufgefasst
  werden
*** Vierecksverfeinerung
- Unterteilt man jede Facette eines beliebigen Netzes N indem man ihre
  Mittelpunkte mit denen ihrere Kanten verbindet, erhält man ein
  Vierecksnetze R_□N wobei R_□ den Vierecksverfeinerungsoperator
  bezeichnet
*** Dreiecksverfeienerung
- Unterteilt man jedes Dreieck eines Dreiecksnetz uniform in 4 gleiche
  Dreiecke erhält man das Netz R_ΔN wobei R_Δ den
  Dreiecksverfeinerungsoperator bezeichnet
*** Mittelungsoperator A
- AN ist das zu N duale Netz, dessen Ecken die Facettenmittelpunkte vno N sind
*** Vierecksmittelpunktschema
- gegeben durch M_{n,□} ≔ A^{n-1} R_□
- Für ein beliebiges Netz N konvergiert die Folge (M_{n,□}^{m}
  N)_{m∈ℕ} gegen eine C^{1}-Fläche und für regelmäßige Vierecknetze
  entspricht M_{n,□} dem Lane-Riesenfeld-Tepus (U_{n},U_{n})
*** Dreiecksmittelungschema
- gegeben durch M_{n,Δ}≔A^{n-1}R_{
- Für ein beliebiges Netz N konvergiert die Folge (M_{n,□}^{m}
  N)_{m∈ℕ} gegen eine C^{1}-Fläche . Für beliebig große n und
  Ausnahmepunkte der Fläche vom Grad 3, ist dies bislang allerdings
  noch nicht bewiesen worden (wtf)
** Haar-Wavelets
- Idee: Umdrehen des Lane-Riesenfeld-Algorithmus U_{0}
- Sei s(u)≔ Σ_{i=0}^{2^{m}-1} c_{i}^{m} N_{i}^{0}(2^{m}u) ein stückweise konstanter Spline über [0,1]
- m-mal mitteln und dabei die enstehenden Fehler berechnen
*** Zerlegung
Für k = m-1,…,0
  Für i=0, …, 2^{k}-1
    c_{i}^{k} ← 1/2 (c_{2i}^{k+1} + c_{2i+1}^{k+1})
    d_{i}^{k} ← 1/2 (c_{2i}^{k+1} - c_{2i}^{k+1})

- Spline s kann aus c_{0}^{0} und den Detailkoeffzienten zurück gewonnen werden
*** Rekonstruktion
Für k=0,…,m-1
  Für i=0,…,2^{k}-1
    c_{2i}^{k+1} ← c_{i}^{k} + d_{i}^{k}
    c_{2i+1}^{k+1} ← c_{i}^{k} - d_{i}^{k}

Sind alle d_{i}^{k} = 0, entspricht die Rekonstruktion dem Lane-Riesenfeld-Algorithmus U_{0}
*** Definition
- Zerlegung lässt sich mit Hilfe der Grundfunktionen
  B_{i}^{k}(u) ≔ N_{i}^{0}(2^{k}u)
und Wavelets
  W_{i}^{k} ≔ B_{2i}^{k+1}-B_{2i+1}^{k+1}
beschreiben
Es gilt
s = Σ_{i=0}^{2^{m-1}-1} (c_{i}^{m-1} B_{i}^{m-1} + d_{i}^{m-1} W_{i}^{m-1})
woraus die Wavelet-Zerlegung folgt
s = c_{0}^{0}B_{0}^{0} + Σ_{i=0}^{2^{0}-1} d_{i}^{0} W_{i}^{0} + …
  + Σ_{i=0}^{2^{m-1}-1} d_{i}^{m-1} W_{i}^{m-1}
*** Bemerkung
- Wavelet-Zerlegung hat wie B-Spline-Darstellung 2^{m} Koeffizienten
- Bezigülich des L_{2}-Skalarprodukts <f,g>≔sqrt(integral_{0}^{1}
  f(x)g(x) dx) sind B_{0}^{0} und die 2^{k}W_{i}^{k} orthonormal
*** Folgerung
- Weglassen der kleinsten δ_{i}^{k} ≔ 2^{-k} d_{i}^{k}
 führt zu guter Komprimierung
*** 2D-Wavelet-Zerlegung
- Grauwertbild wird durch einen stückweise konstanten Spline
s(x,y) ≔ Σ _{i,j=0}^{2^{m}-1} c_{ij}^{m} B_{i}^{m}(x) B_{j}^{m}(y)
über [0,1)^{2} dargestellt
- Seine Waveletzerlegung ergibt sich indem wir die Koeffizientenmatrix
C ≔ [c_{ij}^{m}]_{i,j=0}^{2^{m}-1}
abwechselnd zeilen- und spaltenweise zerlegen
Für m=1 erhält man die Matrix
[c_{00}^{0} d_{00}^{0}] ≔ A^{t} [c_{00}^{1} c_{10}^{1}] A
[e_{00}^{0} f_{00}^{0}]         [c_{01}^{1} c_{11}^{1}]

mit A=[1/2  1/2] und für allgemeine m zerlegen und rekonstruieren wir so
      [1/2 -1/2]
**** Zerlegung^{2}
Für k=m-1,…,0
  Für i,j=0,…,2^{k}-1
    [c_{ij}^{k} d_{ij}^{k}] ← A [c_{2i,2j}^{k+1}   c_{2i+1,2j}^{k+1}]
    [e_{ij}^{k} f_{ij}^{k}]     [c_{2i,2j+1]^{k+1} c_{2i+1, 2j+1}^{k+1}]
**** Rekonstruktion
Siehe Folien
**** Bemerkung
- Zerlegung kann in Quadtree abgespeichert werden
